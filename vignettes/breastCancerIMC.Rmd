---
title: "Unlocking single cell spatial omics analyses with SCDNEY - Demo"
author:
- name: Yue Cao^1,2,3^, Helen Fu^1,2,3^, Jean Yang^1,2,3^
  affiliation:
  - 1. Sydney Precision Data Science Centre, University of Sydney, Australia; \\
  - 2. School of Mathematics and Statistics, University of Sydney, Australia; \\
  - 3. Charles Perkins Centre, University of Sydney, Australia   
date: 1 August, 2023

params:
  evalc: TRUE   ## EDIT to TRUE when generating output, otherwise 'FALSE'
  show: 'hide'  ## EDIT to 'as.is' when generating Suggestions, otherwise 'hide'
output:
  html_document:
    css: https://use.fontawesome.com/releases/v5.0.6/css/all.css
    code_folding: hide
    fig_height: 12
    fig_width: 12
    toc: yes
    number_sections: true
    toc_depth: 3
    toc_float: yes
    self_contained: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  message=FALSE, warning= FALSE)
```


```{r, eval=params$evalc}
## library(devtools)
## library(BiocManager)
library(SingleCellExperiment)
library(ggplot2)
library(scFeatures) ## devtools::install_github("SydneyBioX/scFeatures")
library(ClassifyR) ## BiocManager::install("ClassifyR", dependencies = TRUE)
library(ggthemes)
library(spicyR) ## BiocManager::install("spicyR")
library(dplyr)
library(limma)
library(plotly)
library(scattermore)
library(tidyr)
library(survival)
library(survminer)
library(spatstat)
##library(spatstat.core) ## install.packages("spatstat")
##library(spatstat.geom) 
library(scater)
library(scran)

theme_set(theme_classic())
```

# Overview

As single cell technology advances, the recent development of spatial omics allows us to examine the spatial organisation of cells within tissues in their native environment. This workshop will discuss the challenges and analytical focus associated with disease outcome prediction using multi-sample spatial datasets. We will also talk about general analytical strategies and the critical thinking questions that arise in the workflow.  

<br>
<div class="aimbox"> 
### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-pencil-alt fa-stack-1x fa-inverse"></i></span> Preparation and assumed knowledge {-}
- Knowledge of R syntax
- Familiarity with the [SingleCellExperiment class](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) 
- Ability to install all required R packages, please check `sessionInfo` at the end of this document to ensure you are using the correct version. 

### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-location-arrow fa-stack-1x fa-inverse"></i></span> Learning objectives {-}
- Understand and visualise spatial omics datasets     
- Explore various strategies for disease outcome prediction using spatial omics data      
- Understand and generate individual feature representations from a cell-level expression matrix 
- Develop appreciation on how to assess the performance of classification models   
- Perform disease outcome prediction using the feature representation and robust classification framework     
</div>

<br>

### Time outline {-}
 Structure for this 2-hour workshop:

 | Activity                     | Time    |
 |------------------------------|---------|
 | Introduction to spatial technologies    | 20m  |
 | Cell segmentation with deep learning (with BIDCell)   | 20m  |
 | Exploring spatial data    |  20m    |
 | Break (Q&A) | 10m  |
 | Extracting features from spatial data (with scFeatures)    |  30m    |
 | Performing disease outcome classification (with ClassifyR) |  20m    |

# Initial exploration and visualisation

#### Data and background {-} 

The widely-known METABRIC breast cancer cohort has recently had imaging mass cytometry generated for a subset of it. The publication describing this data is [Imaging Mass Cytometry and Multiplatform Genomics Define the Phenogenomic Landscape of Breast Cancer](https://www.nature.com/articles/s43018-020-0026-6), *Nature Cancer*, 2020. IMC has cell-level resolution. There are 483 cancer sample with IMC data. However, the subset of interest is those patients who do not have lymph node metastasis. Can their risk of recurrence accurately be predicted and therefore inform how aggressively they need to be treated? The other component of the analysis is patient clinical data, which has been sourced from Supplementary Table 5 of Dynamics of [Breast-cancer Relapse Reveal Late-recurring ER-positive Genomic Subgroups](https://www.nature.com/articles/s41586-019-1007-8), *Nature*, 2019.

Basic characteristics of the data objects:   

- The dataset contains 38 proteins and 76307 cells.   
- The outcome is recurrence-free survival.

```{r eval=TRUE}
load("~/data/breastCancer.RData")
data_sce <- IMC

print("data format")
assay(data_sce)[1:5, 1:5]
```

The original data has been restricted to images with at least 400 cells, no lymph node cancer and Stage 1.

#### Aim {-} 
In this demo, we will fit survival models and evaluate the features selected to build them.   

### Exploration 1: How complex is my data? {-} 
At the start of the exploration, it is often good to get a sense of the complexity of the data.  We usually do this by exploring the distribution of the outcomes and various variables in the patient's meta-data.  Here, we use cross-tabulation to examine the following variables:

- Surgery vs death
- ER status
- Grade

```{r eval=params$evalc, fig.height=5, fig.width=5}
print("Stage and death")
table(clinical$Breast.Surgery, clinical$Death, useNA = "ifany") 

print("Number of patients based on ER status")
table(clinical$ER.Status)

print("Number of patients based on Grade")
table(clinical$Grade)
```

### Exploration 2: How to visualise my data? {-} 
Typically in single-cell data analysis, we perform dimension reduction to project the high dimensional cell by gene matrix on to 2D space. This allows us to visualise various things of interest, such as distribution of cell types and disease outcomes. In this dataset, cells were classified into 22 cell types based on their markers.   


*Note:* for single-cell RNA-seq with around 20,000 genes, we often need to perform some filtering (e.g. select highly variable genes) to reduce the number of features. Here, given we have less than 50 proteins, there is no need to pre-filter. That being said, we provide some sample code below (commented out) to demonstrate how to identify highly variable genes followed by UMAP visualisation in scRNA-seq data.

```{r eval=FALSE, include=TRUE}
# gene_var <- modelGeneVar(data_sce)
# hvgs <- getTopHVGs(gene_var, prop=0.1)
# data_sce <- runUMAP(data_sce, scale=TRUE,  subset_row = hvgs)
data_sce <- runUMAP(data_sce, scale=TRUE)
```

```{r eval=params$evalc,fig.height=4, fig.width=12}
a <- plotUMAP(data_sce, colour_by = "description")
b <- plotUMAP(data_sce, colour_by = "metabricId")
a + b
```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>     

What can we learn from these illustrations? Is there anything interesting in the plot? Questions to consider include:    

- Q1: Does each cell type cluster together?
- Q2: When there is a large number of categories, are dimensionality reduction plots interpretable or misleading due to overplotting?     

</div>

### Exploration 3: Is there a spatial structure in my data? {-} 
The advantage with spatial omics is that we can examine the organisation of the cell types as it occurs on the tissue slide. Here, we visualise one of the slides from a patient. As an optional exercise, you can 

- permute the spatial coordinates 

to give a sense of what is random ordering. 

```{r fig.height=4, fig.width=6, eval=params$evalc}
one_sample <- data_sce[, data_sce$metabricId  == "MB-0263"]
one_sample  <- colData(one_sample)
one_sample <- data.frame(one_sample)

tableau_palette <- scale_colour_tableau() 
color_codes <- tableau_palette$palette(10)

a <- ggplot(one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = description)) + geom_point(alpha=0.7) +  scale_colour_manual(values = c(color_codes, "lightgrey")) + ggtitle("Original slide")

```

```{r  fig.height=4, fig.width=12, eval=params$evalc}
print("Optional: Permute the cell type labels")
one_sample$description_permute <- sample(one_sample$description)
b <- ggplot(one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour =description_permute)) + geom_point(alpha=0.7) +  scale_colour_manual(values = c(color_codes, "lightgrey")) + ggtitle("Permute the cell type label")

print("Optional: Permute the spatial coordinate")
one_sample$Location_Center_X_permute <- sample(one_sample$Location_Center_X)
one_sample$Location_Center_Y_permute <- sample(one_sample$Location_Center_Y)
c <- ggplot(one_sample, aes(x = Location_Center_X_permute , y = Location_Center_Y_permute, colour = description)) + geom_point(alpha=0.7) +  scale_colour_manual(values = c(color_codes, "lightgrey")) + ggtitle("Permute the X, Y coordinate")
a + b + c
```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong> Critical thinking: </strong>   

- Is there structure in the data real ? 
- What are additional strategies to generate a random distribution? 

</div>


#  Describing tissue microenvrionments and cellular neighbourhoods  

## Do cell type co-localise in specfic regions? 

We begin by examining how can we identify and visualise regions of tissue where spatial associations between cell-types are similar. There are many packages that perform this task andhere we use the [lisaClust function](https://www.bioconductor.org/packages/devel/bioc/html/lisaClust.html) that is based on "local L-function" to spatially cluster cells into different regions with similar cell type composition.

*This has already been pre-loaded for you. Please proceed to the next task.*

```{r eval=FALSE}
set.seed(51773)
BPPARAM <- MulticoreParam(16)

# Cluster cells into spatial regions with similar composition.
data_sce  <- lisaClust(
  data_sce ,
  k = 5,
  Rs = c(20, 50, 100),
  sigma = 50,
  spatialCoords = c("Location_Center_X", "Location_Center_Y"),
  cellType = "description",
  imageID = "ImageNumber" ,
  regionName = "region",
  BPPARAM = BPPARAM
)
```


## Which regions appear to be different between young and old?  

####  Visualise regions on individual level {-}

```{r fig.height=3, fig.width=10 , eval=params$evalc}
metadata <- colData(data_sce)
metadata <- metadata[metadata$metabricId == "MB-0263",  ]
metadata <- data.frame(metadata)

plotlist <- list()
plotlist_celltype <- list()
thisregion  <-  unique(metadata$region)[1]

tableau_palette <- scale_colour_tableau() 
color_codes <- tableau_palette$palette(10)
color_codes <- c(color_codes, "darkgrey") 

names(color_codes) <- c(unique(metadata$description) ,  "other regions")

for ( thisregion in sort(unique(metadata$region))){
        
        selected_region_index <-  metadata$region == thisregion
        
        metadata$selected_region <-  "other regions"
        metadata$selected_region[selected_region_index] <- "selected region"
        
        metadata$celltype <- metadata$description
        metadata$celltype[!selected_region_index ] <-   "other regions"
        
        metadata$celltype <- factor(metadata$celltype, levels = c(unique(metadata$description), "other regions"))

       p <- ggplot(metadata, aes(x = Location_Center_X , y = Location_Center_Y , colour = selected_region  )) + geom_scattermore(pointsize = 1.5) + ggtitle(thisregion) + scale_colour_manual(values = c("grey" , "red"))
         
       
    
       p2 <-  ggplot(metadata, aes(x = Location_Center_X , y = Location_Center_Y , colour =  celltype )) + geom_scattermore(pointsize = 1.5) + ggtitle(thisregion) + scale_colour_manual(values =  color_codes)
       
      plotlist [[thisregion ]] <- p
       
      plotlist_celltype [[thisregion ]] <- p2
}

ggarrange(plotlist = plotlist , ncol = 5, nrow = 1 , common.legend = T )
ggarrange(plotlist = plotlist_celltype , ncol = 5, nrow = 1 , common.legend = T )

```

####  Visualise regions across patients {-}

We can better interpret the region output by summarising the proportion of each cell type in a region across the patients. Looking at the composition of cell types in each region, comparing between Young and Old Patients. A cutoff of 50 years old will be used. 


```{r  fig.height=4, fig.width=10, eval=params$evalc}
df <- data.frame(colData( data_sce))
clinical$AgeGroup <- ifelse(clinical$Age.At.Diagnosis < 50, "Young", "Old")

df_plot <- NULL
for ( thispatient in unique(df$metabricId)){
  this_df <- df[df$metabricId == thispatient, ]
  temp_df <-   table( this_df$region, this_df$description )
  temp_df <-  temp_df / rowSums(temp_df)
   temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- clinical[clinical$metabricId == thispatient, "AgeGroup"]
  df_plot <- rbind(df_plot, temp_df)
}

df_plot <- df_plot %>% dplyr::group_by( Var1 , Var2, group) %>% 
  summarise(mean_proportion = mean(Freq))
  
# r1 <- df_plot[ df_plot$Var1 == "region_1", ]  

ggplot(df_plot, aes(y = Var2, x = Var1 ,colour =mean_proportion  , size = mean_proportion ))+  geom_point() + 
  facet_grid(~group, scales = "free", space = "free" ) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  xlab("Region" ) + ylab("Celltype") + scale_colour_viridis_c()
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   
 
Q4: Which regions appear to be different between Young and Old?        

</div>


```{r  fig.height=4, fig.width=10, eval=params$evalc}
df <- clinical[colData(data_sce)[, "metabricId"], ]
df$region <- data_sce$region
df$description <- data_sce$description

df <- df %>% dplyr::group_by(metabricId , AgeGroup, region) %>%
  count(description) %>%
  mutate(proportion = n / sum(n))


ggplot(df, aes(y = proportion, x = metabricId , fill = description))+ geom_col()+facet_grid(~region+AgeGroup, scales = "free", space = "free" ) + scale_fill_manual(values = c(color_codes))  +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())


```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>

Q5: Does your conclusion change after looking at a different plot?    

</div>


## Further exploration by visualising selected regions    
We see that region 1 appears to suggest the non-responder patients have more melano. Region 3 appears to be the tumor microenvironment with lots of Th.ae (antigen-experienced) and macro.mono (macrophage and monocytes) cell types. Let's focus on region 1 and region 3 and visualise the data with boxplots, as well as comparing to the overall cell type proportion without segmenting into regions.   

```{r fig.height=4, fig.width= 12 , eval=params$evalc}
df_plot <- NULL
for ( thispatient in unique(df$metabricId)){
  this_df <- df[df$metabricId == thispatient, ]
  temp_df <-   table( this_df$region, this_df$description )
  temp_df <-  temp_df / rowSums(temp_df)
  temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- unique( this_df$AgeGroup)
  df_plot <- rbind(df_plot, temp_df)
}

df_plot_region_1 <- df_plot[df_plot$Var1 == "region_1", ]
 
a <- ggplot(df_plot_region_1, aes(x =  Var2,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  ylab("Proportion") + xlab("Cell type")+ ggtitle("Region 1") + ylim(0, 0.25)


df_plot_region_3 <- df_plot[df_plot$Var1 == "region_3", ]

b <- ggplot(df_plot_region_3, aes(x =  Var2,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
  ylab("Proportion") + xlab("Cell type") + ggtitle("Region 3") + ylim(0, 0.25)
 


overall <- NULL
for ( thispatient in unique(df$metabricId)){
  
  this_df <- df[df$metabricId == thispatient, ]
  
  temp_df <-   table(  this_df$description )
  temp_df <-  temp_df /sum(temp_df)
   temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- unique( this_df$AgeGroup )
  overall <- rbind(overall, temp_df)
}


c <- ggplot(overall, aes(x =  Var1,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
  ylab("Proportion") + xlab("Cell type") + ggtitle("Overall composition")
 

a + b + c
```

#### Selecting a specific marker for further exploration {-}
Often you may have a marker in mind to further examine the expression of key marker genes in these region specific cell types.  For example, we select cells that have high Ki67 expression.  (ie, only keeping the cells that have Ki67 expression higher than the median Ki67 expression in the whole dataset). We choose Ki67 as an example here because Ki67 is strongly associated with tumor cell proliferation and growth and is widely used as a biomarker in cancer analysis.    


```{r fig.height=4, fig.width= 12, eval=params$evalc}

median_ki67 <- median( logcounts(data_sce[ "Ki67" , ]))
data_sce$ki67 <- ifelse( logcounts(data_sce[ "Ki67" , ]) > median_ki67, "high_ki67" , "low_ki67")


df_plot <- NULL
for ( thispatient in unique(df$metabricId)){
  this_df <- df[df$metabricId == thispatient, ]
  temp_df <-   table( this_df$region, this_df$description )
  temp_df <-  temp_df / rowSums(temp_df)
  temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- unique( this_df$AgeGroup )
  df_plot <- rbind(df_plot, temp_df)
}

df_plot_region_1 <- df_plot[df_plot$Var1 == "region_1", ]
 
a <- ggplot(df_plot_region_1, aes(x =  Var2,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  ylab("Proportion") + xlab("Cell type")+ ggtitle("Region 1") + ylim(0, 0.25)


df_plot_region_3 <- df_plot[df_plot$Var1 == "region_3", ]

b <- ggplot(df_plot_region_3, aes(x =  Var2,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
  ylab("Proportion") + xlab("Cell type") + ggtitle("Region 3") + ylim(0, 0.25)
 


overall <- NULL
for ( thispatient in unique(df$metabricId)){
  
  this_df <- df[df$metabricId == thispatient, ]
  
  temp_df <-   table(  this_df$description )
  temp_df <-  temp_df /sum(temp_df)
   temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- unique( this_df$AgeGroup )
  overall <- rbind(overall, temp_df)
}


c <- ggplot(overall, aes(x =  Var1,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
  ylab("Proportion") + xlab("Cell type") + ggtitle("Overall composition") + ylim(0, 0.25)
 

a + b + c
```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong> Discussion:</strong>

Comparing the overall composition and the cell type composition in the region, what did you observe about the regions? 
</div>


#  How do we generate a molecular representation for each individual?  

In this demo, we use scFeatures to generate molecular representation for each patient from the matrix of proteins by cells. The molecular representation is interpretable and hence facilitates downstream analysis of the patient. Overall, scFeatures generates features across six categories representing different molecular views of cellular characteristics. These include:

i) cell type proportions
ii) cell type specific gene expressions
iii) cell type specific pathway expressions
iv) cell type specific cell-cell interaction (CCI) scores
v) overall aggregated gene expressions
vi) spatial metrics

The different types of features constructed enable a more comprehensive multi-view understanding of each patient from a matrix of proteins x cells.

Given in the previous section, we clustered the cells into regions, we can use the region information as an additional layer of information on top of the cell types to examine region-specific cell-type specific features. 

```{r eval=FALSE}
region <- data_sce$region
region <- gsub("_" , "", region)
data_sce$celltype <- paste0( data_sce$description , "-" , region)
```

```{r}
print("number of cells in each sample")
table(data_sce$metabricId) 

print("number of cells in each celltype - Region specific cell type")
table(data_sce$celltype) 
```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong> Discussion:</strong>

Are there any samples or cell types you would like to remove from the data?

</div>


## How to create molecular representations of patients {-}

All the feature types can be generated in one line of code. This runs the function using default settings for all parameters. For more information, type `?scFeatures`. To save time, **just load the prepared RDS file in the following chunk.**

```{r eval=FALSE, include=TRUE}

# scFeatures requires the following columns 
# celltype, sample, x_cord and y_cord
# alternatively, these can be also set as argument in the scFeatures function 
 
IMCmatrix <- assay(data_sce)
sample = data_sce$metabricId
celltype = data_sce$celltype
spatialCoords <- list(colData(data_sce)$Location_Center_X, colData(data_sce)$Location_Center_Y)

# here, we specify that this is a spatial proteomics data
# scFeatures support parallel computation to speed up the process 
scfeatures_result <- scFeatures(IMCmatrix, type = "spatial_p", sample = sample, celltype = celltype, spatialCoords = spatialCoords,
                                ncores = 32)
```

```{r}
scfeatures_result <- readRDS("~/data/scfeatures_result.RDS")
```

## How to explore scFeatures output?
We have generated a total of 13 feature types and stored them in a list. All generated feature types are stored in a matrix of samples by features.
For example, the first list element contains the feature type `proportion_raw`, which contains the cell type proportion features for each patient sample. We could print out the first 5 columns and first 5 rows of the first element to see.

```{r eval=params$evalc}
# we have generated a total of 13 feature types
names(scfeatures_result)

# each row is a sample, each column is a feature 
data.frame(scfeatures_result[[1]][1:5, 1:5])
## DT::datatable(meta_table , options = list(scrollX = TRUE))
```

# Can we predict recurrence risk? 

### Building a classification model {-}

In this section, we will perform disease outcome classification using the molecular representation of patients. Recall in the previous section that we have stored the 13 feature types matrix in a list. Instead of manually retrieving each matrix from the list to build separate models, classifyR can directly take a list of matrices as an input and run a repeated cross-validation model on each matrix individually. Below, we run 5 repeats of 5-fold cross-validation. The patient outcome is time-to-event, so, by default, ClassifyR will use Cox proportional hazards ranking to choose a set of features and also Cox proportional hazards to predict risk scores. Other models are available. A high score indicates prection of a worse outcome than a lower risk score.

```{r eval=TRUE, include=TRUE}
usefulFeatures <- c("Breast.Tumour.Laterality", "ER.Status", "Inferred.Menopausal.State", "Grade", "Size")
nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result, function(metaFeature) 1:5))
clinicalAndOmics <- append(list(clinical = clinical), scfeatures_result)

### generate classfyr result 

classifyr_result <- crossValidate(clinicalAndOmics, c("timeRFS", "eventRFS"),
                    extraParams = list(prepare = list(useFeatures = list(clinical = usefulFeatures))),
                    nFeatures = nFeatures, nFolds = 5, nRepeats = 5, nCores = 5)
```

Cox proportional hazards is a traditional statistical method. Compare the predictive performance with a machine learning method. Random survival forest will be used. Such models can build remarkably complex relationships between features. Note, however, the running time is much longer than Cox proportional hazards and feature selection is used to limit the number of features considered to 100 at most per metafeature. To save time, **just load the prepared RDS file.**

```{r, eval = FALSE}
nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result[2:length(scfeatures_result)], function(metaFeature) min(100, ncol(metaFeature))))
survForestCV <- crossValidate(clinicalAndOmics, outcome, nFeatures = nFeatures,
                classifier = "randomForest",
                nFolds = 5, nRepeats = 5, nCores = 5)
```

```{r}
survForestCV <- readRDS("~/data/survForestCV.RDS")
```

### Visualising the classification performance of individual metafeatures {-}

To examine the distribution of prediction performance. use `performancePlot`. Currently, the only metric for time-to-event data is C-index and that will automatically be used because the predictive model type is tracked inside of the result objects.

```{r eval=params$evalc}
tilt <- theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
performancePlot(append(classifyr_result, survForestCV),
                characteristicsList = list(x = "Assay Name", row = "Classifier Name"),
                orderingList = list("Assay Name" = names(scfeatures_result))) + tilt
```

Note how the resultant plot is a ggplot2 object and can be further modified.

The same code could be used for a categorical classifier because the random forest implementation provided by ranger package has the same interface for both.

Next, examine feature selection stability with `selectionPlot`.

```{r}
selectionPlot(append(classifyr_result, survForestCV),
                characteristicsList = list(x = "Assay Name", row = "Classifier Name"),
                orderingList = list("Assay Name" = names(scfeatures_result))) + tilt
distribution(classifyr_result[[1]], plot = FALSE)
```

Using `samplesMetricMap` compare the per-sample C-index for Cox and Random Forest models for metafeature gene_cor_celltype.

```{r}
library(grid)
heatmap <- samplesMetricMap(list(classifyr_result[[7]], survForestCV[[7]]))
grid.draw(heatmap)
```

A few samples are predicted better by one model than another.

The per-sample C-index is a metric unique to ClassifyR. Models and feature selection approaches may be seen in the vignette or listed by `available()`.

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   

Q8: Is highest predictive performance the only way to choose the best model or are other models the best for other reasons?
</div>

## PART A: Explanation of spatial features 

- L function:

The L function is a spatial statistic used to assess the spatial distribution of cell types. It assesses the significance of cell-cell interactions, by calculating the density of a cell type with other cell types within a certain radius. High values indicate spatial association, low values indicate spatial avoidance.

```{r fig.height=4, fig.width=10, eval=params$evalc}
 
one_sample  <- data_sce[ , data_sce$metabricId == "MB-0128"  ]
one_sample <- data.frame( colData(one_sample) )

one_sample$celltype <- one_sample$description
index <-  one_sample$celltype  %in% c("B cells", "Fibroblasts")
one_sample$celltype[!index] <- "others"
a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0128 - high L value with \n B cells interacting Fibroblasts")
 

one_sample$celltype <- one_sample$description
index <-  one_sample$celltype  %in% c("melano", "Tc.ae")
one_sample$celltype[!index] <- "others"
b <- ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0128 - low L value with \n B cells interacting HR_ CK7")
 
a + b
```




- Cell type interaction composition:

We calculate the nearest neighbours of each cell and then calculate the pairs of cell types based on the nearest neighbour. This allows us to summarise it into a cell type interaction composition.


```{r fig.height=6, fig.width=10, eval=params$evalc}
 
one_sample  <- data_sce[ , data_sce$metabricId == "MB-0263"  ]
one_sample <- data.frame( colData(one_sample) )

one_sample$celltype <- one_sample$description
 
a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0263")


feature  <- scfeatures_result$celltype_interaction
to_plot <- data.frame( t( feature["MB-0263", ])  )
to_plot$feature <- rownames(to_plot) 
colnames(to_plot)[2] <- "celltype interaction composition"
 
to_plot <- to_plot[ to_plot$MB.0263 > 0.03 , ] 
b <- ggplot(to_plot, aes(x = reorder(`celltype interaction composition`, MB.0263) ,  y = MB.0263, fill=`celltype interaction composition`)) + geom_bar(stat="identity" ) + ylab("Major cell type interactions")  +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 

a+ b
```



- Moran's I:   

Moran's I is a spatial autocorrelation statistic based on both location and values. It quantifies whether similar values tend to occur near each other or are dispersed.     


```{r fig.height=4, fig.width=10 , eval=params$evalc}

high  <- data_sce["Ki67", data_sce$metabricId == "MB-0132"  ]
high_meta <- data.frame( colData(high) ) 
high_meta$expression <- as.vector(logcounts( high)) 

low  <- data_sce["Ki67",  data_sce$metabricId == "MB-0249" ]
low_meta <- data.frame( colData(low) )
low_meta$expression <- as.vector(logcounts(low))


a <- ggplot(high_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient MB-0132 - high Moran's I in Ki67")

b <- ggplot(low_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient MB-0249 - low Moran's I in Ki67")

a+b

```



- Nearest Neighbor Correlation:    

This metric measures the correlation of proteins/genes between a cell and its nearest neighbour cell.   

```{r fig.height=5, fig.width=10, eval=params$evalc}


    
 plot_nncorrelation <- function(thissample , thisprotein){
   
       sample_name <- thissample
       thissample <- data_sce[, data_sce$metabricId ==     sample_name]
    
      
      exprsMat <- logcounts(thissample)
     
    
    cell_points_cts <- spatstat.geom::ppp(
            x = as.numeric(thissample$Location_Center_X ), y = as.numeric(thissample$Location_Center_Y),
            check = FALSE,
            xrange = c(
                min(as.numeric(thissample$Location_Center_X)),
                max(as.numeric(thissample$Location_Center_X))
            ),
            yrange = c(
                min(as.numeric(thissample$Location_Center_Y)),
                max(as.numeric(thissample$Location_Center_Y))
            ),
            marks = t(as.matrix(exprsMat))
        )
    
     value <-  spatstat.explore::nncorr(cell_points_cts)["correlation", ]
      value <-  value[  thisprotein]
     
    # Find the indices of the two nearest neighbors for each cell
    nn_indices <- nnwhich(cell_points_cts, k = 1)
    
    protein <-  thisprotein
    df <- data.frame(thiscell_exprs  = exprsMat[protein, ] , exprs =  exprsMat[protein,nn_indices ])
    
   p <-  ggplot(df, aes( x =thiscell_exprs ,  y = exprs , colour =  exprs  )) +
      geom_point(alpha = 0.3) + ggtitle(paste0( "Patient ", sample_name ,  " nn_corr = " ,  round(value, 2)  )) + scale_colour_viridis_c() 
   
   return (p ) 

}

    
p1 <- plot_nncorrelation("MB-0605",  "HER2")
p2 <- plot_nncorrelation("MB-0258",  "HER2")
p1  + p2
```

The correlation differs between the 42RD patient (from cluster 1) and the 29RD patient (from cluster 2).    


## PART C: SessionInfo

```{r  eval=params$evalc}
sessionInfo()
```

## Acknowledgment 
The authors thank all their colleagues, particularly at The University of Sydney, Sydney Precision Data Science and Charles Perkins Centre for their support and intellectual engagement. Special thanks to Ellis Patrick, Shila Ghazanfar, Andy Tran for guiding and supporting the building of this workshop.