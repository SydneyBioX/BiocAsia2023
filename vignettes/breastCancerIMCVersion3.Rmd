---
title: "Unlocking single cell spatial omics analyses with scdney"
author:
- name: Yue Cao^[yue.cao@sydney.edu.au], Andy Tran^[andy.t@sydney.edu.au], Dario Strbenac^[dario.strbenac@sydney.edu.au], Nicholas Robertson^[nicholas.robertson@sydney.edu.au], Jean Yang^[jean.yang@sydney.edu.au]
  affiliation:
  - 1. Sydney Precision Data Science Centre, University of Sydney, Australia;    
  - 2. School of Mathematics and Statistics, University of Sydney, Australia;     
  - 3. Charles Perkins Centre, University of Sydney, Australia;   
  - 4. Laboratory of Data Discovery for Health Limited (D24H), Science Park, Hong Kong SAR, China.  
date: 15 October, 2023

params:
  evalc: TRUE   ## EDIT to TRUE when generating output, otherwise 'FALSE'
  show: 'hide'  ## EDIT to 'as.is' when generating Suggestions, otherwise 'hide'
output:
  html_document:
    css: https://use.fontawesome.com/releases/v5.0.6/css/all.css
    code_folding: hide
    fig_height: 12
    fig_width: 12
    toc: yes
    number_sections: true
    toc_depth: 3
    toc_float: yes
    self_contained: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  message=FALSE, warning= FALSE)


library(SingleCellExperiment)
load("~/data/breastCancer.RData")
data_sce = IMC
```


```{r, eval=params$evalc }
## library(devtools)
## library(BiocManager)
library(SingleCellExperiment)
library(ggplot2)
library(scFeatures) ## devtools::install_github("SydneyBioX/scFeatures")
library(ClassifyR) ## BiocManager::install("ClassifyR", dependencies = TRUE)
library(lisaClust)
library(ggthemes)
library(spicyR) ## BiocManager::install("spicyR")
library(dplyr)
library(limma)
library(plotly)
library(scattermore)
library(tidyr)
library(survival)
library(survminer)
library(spatstat)
library(scater)
library(scran)
library(reshape)

theme_set(theme_classic())
```


```{r eval=params$evalc}

# code for plotting purpose


plot_boxplot <- function( feature ){
  
  data <- t(feature)

  patient <- unlist( lapply( strsplit( colnames(data), "_cond_"), `[`, 1) ) 
  condition  <- unlist( lapply( strsplit( colnames(data), "_cond_"), `[`, 2))
  condition <- data.frame(sample = patient, condition = condition )
      
 

  design <- model.matrix(~condition, data = condition)
  fit <- lmFit(data, design)
  fit <- eBayes(fit)
  tT <- topTable(fit, n = Inf) 
  
  
  # selecting the top 10 DE features 
  top_gene <- rownames( tT)[1:10 ]
  rownames( condition) <- colnames(data)
   
  data_plot <-  data[top_gene, ]   
  
  data_plot <- melt(data_plot )
  
  colnames(data_plot) <- c("X1", "X2", "value")
  data_plot$condition <- unlist( lapply( strsplit(  as.character( data_plot$X2), "_cond_"), `[`, 2))
  
 
  p <- ggplot(data_plot, aes( x = X1, y = value , colour = condition)) + 
    geom_boxplot()  + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  
   
  return(p)
  
}
  

plot_barplot <- function(data , dodge=F  ){
  

  data$patient <- unlist( lapply( strsplit( rownames(data ), "_cond_"), `[`, 1))
  data$condition <- unlist( lapply( strsplit( rownames(data ), "_cond_"), `[`, 2))
  
  data <- as.data.frame( melt(data, id=c("patient", "condition")) )
 
 
  p <-   ggplot(data , aes( x = patient , y = value , fill = variable) ) +   
    geom_bar(stat="identity"   ) + facet_wrap(~condition, scale="free") + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 
 
  
 
 return (p)
  
 
 
}



```


# Overview

As single cell technology advances, the recent development of spatial omics allows us to examine the spatial organisation of cells within tissues in their native environment. This workshop will discuss the challenges and analytical focus associated with using multi-sample spatial datasets for disease risk prognosis. We will also talk about general analytical strategies and the critical thinking questions that arise in the workflow.  

<br>
<div class="aimbox"> 
### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-pencil-alt fa-stack-1x fa-inverse"></i></span> Preparation and assumed knowledge {-}
- Knowledge of R syntax
- Familiarity with the [SingleCellExperiment class](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) 
- Basic knowledge in [single cell data analysis](https://bioconductor.org/books/release/OSCA/index.html). You can access our [previous workshops](https://github.com/SydneyBioX/scdney#scdney-workshops-series) for a quick review in single cell data analysis.
- Ability to install all required R packages, please check `sessionInfo` at the end of this document to ensure you are using the correct version. 
Familiarity with our previous workshop vignette on [Introduction to Single Cell RNA-seq Analysis](https://sydneybiox.github.io/BIS2019_SC/) 

### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-location-arrow fa-stack-1x fa-inverse"></i></span> Learning objectives {-}
- Describe and visualise spatial omics datasets     
- Calculate different measures that describe the spatial distribution of cell types
- Generate individual feature representations from a cell-level expression matrix 
- Perform multi-view disease outcome prognosis with the package `ClassifyR`
- Develop understanding on 
  + how to assess the performance of classification and survival models  
  + how to identify and assess individual performance given a survival model. 
- Explore various strategies for disease outcome prognosis using spatial omics data      
</div>

**Note:** This data analysis workshop offers participants the opportunity to engage in hands-on analysis using R. However, if you are not comfortable with coding in R, you can still acquire valuable interpretation skills by reviewing the output we provide in this file.
<br>

### Time outline

Structure of the 3-hour workshop:

| Activity                              | Time |
|---------------------------------------|------|
| Introduction                          | 15m  |
| Exploring spatial data                | 35m  |
| Feature engineering with scFeatures   | 50m  |
| Break                                 | 15m  |
| Survival analysis with ClassifyR      | 45m  |
| Identify cohort heterogeneity         | 20m  |
| Concluding remarks                    |      |

# Initial exploration and visualisation

### Data and background {-} 

The widely-known METABRIC breast cancer cohort has recently had imaging mass cytometry (cell-level resolution) generated for a subset of it. The publication describing this data is [Imaging Mass Cytometry and Multiplatform Genomics Define the Phenogenomic Landscape of Breast Cancer](https://www.nature.com/articles/s43018-020-0026-6), *Nature Cancer*, 2020. There are 483 cancer samples with IMC data. However, the subset of interest is those patients who do not have lymph node metastasis. Can their risk of recurrence accurately be estimated and therefore inform how aggressively they need to be treated? The other component of the analysis is patient clinical data, which has been sourced from Supplementary Table 5 of [Dynamics of Breast-cancer Relapse Reveal Late-recurring ER-positive Genomic Subgroups](https://www.nature.com/articles/s41586-019-1007-8), *Nature*, 2019.

The original data has been restricted to images with at least 400 cells, no lymph node cancer and Stage 1.

```{r eval=params$evalc}
load("~/data/breastCancer.RData")
data_sce <- IMC


## Quick look at data
data_sce
```


```{r}
logcounts(data_sce)[1:5, 1:5]
```


Basic characteristics of the data objects:   

- The dataset contains `r nrow(assay(data_sce))` proteins 
and `r ncol(assay(data_sce))` cells.   
- The outcome is recurrence-free survival.



```{r}
## The object stores meta data (such as patient outcome information) about each cell
## the metadata is stored in colData() 
# we need to convert to a data.frame to be input into datatable function
DT::datatable( data.frame(colData(data_sce))[1:5, ], options = list(scrollX = TRUE))

```



## Exploration 1: How complex is my data?  

At the start of any analysis pipeline, it is often good to explore the data to get a sense of the complexity.  We usually do this by exploring the distribution of the outcomes and various variables in the patients' meta-data.  Here, we use cross-tabulation to examine the following variables:

- Surgery vs death
- ER status
- Grade

```{r eval=params$evalc, fig.height=5, fig.width=5}
print("Stage and death")
table(clinical$Breast.Surgery, clinical$Death, useNA = "ifany") 
```


```{r}
print("Number of patients based on ER status")
table(clinical$ER.Status, useNA = "ifany")
```


```{r}
print("Number of patients based on Grade")
table(clinical$Grade , useNA = "ifany")
```

## Exploration 2: How to visualise my data? 

Typically in single-cell data analysis, we perform dimension reduction to project the high dimensional cell x gene matrix on to 2D space. This allows us to visualise various things of interest, such as distribution of cell types and disease outcomes. In this dataset, cells were classified into 22 cell types based on their markers.   



```{r eval=FALSE, include=TRUE}
data_sce <- runUMAP(data_sce, scale=TRUE)
```

```{r eval=params$evalc,fig.height=4, fig.width=12}

# With the UMAP function we can highlight by meta data of interest
# Here we highlight the cell types and sample ID
a <- plotUMAP(data_sce, colour_by = "description")
b <- plotUMAP(data_sce, colour_by = "metabricId")

ggarrange( plotlist = list(a,b))

```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>     

What can we learn from these illustrations? Is there anything interesting in the plot? Questions to consider include:    

- Q1: Does each cell type cluster together?
- Q2: When there is a large number of categories, are dimensionality reduction plots interpretable or misleading due to overplotting?     

</div>

Visualise selected patient:   
Here we selectively visualise two patients by highlighting only the selected patients.   

```{r fig.height=4, fig.width= 12 , eval=params$evalc}

# extract the meta data and the UMAP dimension of the dataset
metadata <- colData(data_sce)
metadata <- cbind(metadata, reducedDim(data_sce, "UMAP"))
metadata <- data.frame(metadata)

# for the selected patient, denote it as "selected patient" and all other patients as "other patients"
metadata$selected_patient <- ifelse( metadata$metabricId == "MB-0475", "seleted patient" , "other patients")
        
a <- ggplot(metadata, aes(x =UMAP1 , y = UMAP2 , colour = selected_patient  )) + geom_scattermore(pointsize = 0.5)  + scale_colour_manual(values = c("grey" , "red"))
 
# repeat for another patient 
metadata$selected_patient <- ifelse( metadata$metabricId == "MB-0628", "seleted patient" , "other patients")
        
b <- ggplot(metadata, aes(x =UMAP1 , y = UMAP2 , colour = selected_patient  )) + geom_scattermore(pointsize = 0.5)  + scale_colour_manual(values = c("grey" , "red"))
 
ggarrange(plotlist = list(a,b ))
 
```



## Exploration 3: Is there a spatial structure in my data? {.tabset}


The advantage with spatial omics is that we can examine the organisation of the cell types as it occurs on the tissue slide. Here, we visualise one of the slides from a patient. As an optional exercise, you can: 

- permute the cell type label.   
- permute the spatial coordinate.           

to give a sense of what is random ordering.       
 
### Spatial plot 
Here we choose a particular patient "MB-0263" and visualise its spatial pattern. 


```{r fig.height=4, fig.width=6, eval=params$evalc}

# obtaining the meta data for this patient 
one_sample <- data_sce[, data_sce$metabricId  == "MB-0263"]
one_sample  <- colData(one_sample)
one_sample <- data.frame(one_sample)
 
a <- ggplot(one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = description)) + geom_point(alpha=0.7) + scale_colour_tableau() + ggtitle("Original slide")

```

### [Optional code] Random spatial pattern

The code here investigates permutations of spatially resolved data. Please examine the next tab for actual results. 

```{r eval=params$evalc}
# "Optional: Permute the cell type labels"
one_sample$description_permute <- sample(one_sample$description)
b <- ggplot(one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour =description_permute)) + geom_point(alpha=0.7)  + scale_colour_tableau() + ggtitle("Permute the cell type label")
```

```{r eval=params$evalc}
# "Optional: Permute the spatial coordinate"
one_sample$Location_Center_X_permute <- sample(one_sample$Location_Center_X)
one_sample$Location_Center_Y_permute <- sample(one_sample$Location_Center_Y)
c <- ggplot(one_sample, aes(x = Location_Center_X_permute , y = Location_Center_Y_permute, colour = description)) + geom_point(alpha=0.7)  + scale_colour_tableau() + ggtitle("Permute the X, Y coordinate")
```


### Spatial structure

The aim here is to have an understanding of the concept of spatial randomness.  Spatial statistics is a topic of study that encompasses a wide range of research. The next two code chucks focus on the examination of two distinct permutation strategies. The objective of this investigation is to gain an understanding of how various permutation strategies might yield varied perceptions of randomness. 

```{r  fig.height=4, fig.width=12, eval=params$evalc}
## ggarrange provides a way to arrange multiple ggplots for efficient visual comparison

ggarrange( plotlist = list(a, b, c), ncol = 3) 
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   

Q3: Is there a structure in the data or is the cell type randomly distribution? 

</div>




#  Describing tissue microenvrionments and cellular neighbourhoods 

Spatial data allow for the identification of a variety of characteristics including distinct cell types within an image, providing an overview of the tissue environment. This allows scientists to explore the cellular architecture and environment and its association with phenotype information (e.g meta-data). For our data story, we are interested in whether the patients have a good or poor outcome. The outcome is often called a 'prognosis' and a good outcome is sometimes called 'favourable'. In this section, we examine graphically how cell-type co-localisation varies across spatial regions and how is such information associated with individual survival outcome. 


## Do cell type co-localise in specfic regions? 

We begin by examining how can we identify and visualise regions of tissue where spatial associations between cell-types are similar. There are many packages that perform this task and here we use the [lisaClust function](https://www.bioconductor.org/packages/devel/bioc/html/lisaClust.html) that is based on "local L-function" to spatially cluster cells into different regions with similar cell type composition.

<p style="color:blue">
*This has already been pre-loaded for you. Please proceed to the next task.*
</p>

```{r eval=FALSE}
set.seed(51773)
BPPARAM <- MulticoreParam(16)

# Cluster cells into spatial regions with similar composition.
data_sce  <- lisaClust(
  data_sce ,
  k = 5,
  Rs = c(20, 50, 100),
  sigma = 50,
  spatialCoords = c("Location_Center_X", "Location_Center_Y"),
  cellType = "description",
  imageID = "ImageNumber" ,
  regionName = "region",
  BPPARAM = BPPARAM
)
```


## Which regions appear to be different between short survival and long survival?  {.tabset}

As a case study, we first compare individuals with good or poor prognosis. We define:     

- good prognosis as individuals with > 10 years survival and 
- poor prognosis as individuals with < 5 years survival. 

We examine different ways of visualising data.

###  Individual level

Here we visualise the region result based on one individual.   


```{r fig.height=3, fig.width=10 , eval=params$evalc}

# get meta data for a selected patient to visualise 
metadata <- colData(data_sce)
metadata <- metadata[metadata$metabricId == "MB-0628",  ]
metadata <- data.frame(metadata)


plotlist <- list() # define the list to store images for region highlighting 
plotlist_celltype <- list() # define the list to store images for celltype highlighting 
 
# optional: define a colour palette
# you can also specify your own colour to use in the variable color_codes 
tableau_palette <- scale_colour_tableau( palette = "Tableau 20") 
color_codes <- tableau_palette$palette(18)
color_codes <- c(color_codes, "darkgrey")  # for all other regions apart from region of interest, make the colour grey 
names(color_codes) <- c(unique(metadata$description) ,  "other regions")


# look through each region to highlight the region of interest, as well as the cell type in the region of interest
for ( thisregion in sort(unique(metadata$region))){
      
        # select the region of interest
        selected_region_index <-  metadata$region == thisregion
        
        # for all other regions, define them as "other regions" so that they will be greyed out 
        metadata$selected_region <-  "other regions"
        metadata$selected_region[selected_region_index] <- "selected region"
        
        # for all cell types outside the region of the interest, also make them greyed out 
        metadata$celltype <- metadata$description
        metadata$celltype[!selected_region_index ] <-   "other regions"
        metadata$celltype <- factor(metadata$celltype, levels = c(unique(metadata$description), "other regions"))

        # plot ggplot highlighting the region of interest
       p <- ggplot(metadata, aes(x = Location_Center_X , y = Location_Center_Y , colour = selected_region  )) + geom_point(alpha = 0.7) + ggtitle(thisregion) + scale_colour_manual(values = c("grey" , "red"))
         
       # plot ggplot highlighting the celltypes in the region of interest 
       p2 <-  ggplot(metadata, aes(x = Location_Center_X , y = Location_Center_Y , colour =  celltype )) + geom_point(alpha = 0.7 ) + ggtitle(thisregion) + scale_colour_manual(values =  color_codes)
       
      plotlist [[thisregion ]] <- p
       
      plotlist_celltype [[thisregion ]] <- p2
}

ggarrange(plotlist = plotlist , ncol = 5, nrow = 1 , common.legend = T )
ggarrange(plotlist = plotlist_celltype , ncol = 5, nrow = 1 , common.legend = T )

```

###  Across individuals

We can better interpret the region output by summarising the proportion of each cell type in a region across the patients. Looking at the composition of cell types in each region, comparing between prognostic outcome.  


```{r  fig.height=4, fig.width=10, eval=params$evalc}
df <- data.frame(colData( data_sce))
 
clinical$survivalgroup <- clinical$timeRFS
clinical$survivalgroup[which( clinical$timeRFS  < 5* 365) ] <- "less than 5 years" 
clinical$survivalgroup[which( clinical$timeRFS  > 10* 365) ] <-  "more than 10 years"

 
# for each patient, calculate the proportion of each cell type in each region.  
df_plot <- NULL
for ( thispatient in unique(df$metabricId)){
  this_df <- df[df$metabricId == thispatient, ]
  temp_df <-   table( this_df$region, this_df$description )
  temp_df <-  temp_df / rowSums(temp_df)
   temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- clinical[clinical$metabricId == thispatient, "survivalgroup"]  
  df_plot <- rbind(df_plot, temp_df)
}

# for each region, calculate the average proportion of each cell type across all patients 
df_plot <- df_plot %>% dplyr::group_by( Var1 , Var2, group) %>% 
  summarise(mean_proportion = mean(Freq))
  
# we are only interested in the short term and long term survival patients 
df_plot  <- df_plot [ df_plot$group %in% c("less than 5 years",  "more than 10 years"), ]
 
ggplot(df_plot, aes(y = Var2, x = Var1 ,colour =mean_proportion  , size = mean_proportion ))+  geom_point() + 
  facet_grid(~group, scales = "free", space = "free" ) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  xlab("Region" ) + ylab("Celltype") + scale_colour_viridis_c()
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   
 
Q4: Which regions appear to be different between poor prognosis (short-term survival) and good prognosis (long-term survival) patients?        

</div>



### Further exploration by visualising selected regions   

Let's focus on region 5 and visualise the data with boxplots.    

```{r fig.height=4, fig.width= 12 , eval=params$evalc}
 
df <- clinical[colData(data_sce)[, "metabricId"], ]
df$region <- data_sce$region
df$description <- data_sce$description

df_plot <- NULL
for ( thispatient in unique(df$metabricId)){
  this_df <- df[df$metabricId == thispatient, ]
  temp_df <-   table( this_df$region, this_df$description )
  temp_df <-  temp_df / rowSums(temp_df)
  temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$group <- unique( this_df$survivalgroup)
  df_plot <- rbind(df_plot, temp_df)
}

 
df_plot_region <- df_plot[df_plot$Var1 == "region_5", ]

  
df_plot_region  <-  df_plot_region [ df_plot_region$group %in% c("less than 5 years",  "more than 10 years"), ]
 
ggplot(df_plot_region,  aes(x =  Var2,  y = Freq, colour = group)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
  ylab("Proportion") + xlab("Cell type") + ggtitle("Selected region") + ylim(0, 0.25)
 
 

 
```


#  How do we generate a molecular representation for each individual? 


In this demo, we use scFeatures to generate a molecular representation for each patient from the matrix of proteins x cells. The molecular representation is interpretable and hence facilitates downstream analysis of the patient. Overall, scFeatures generates features across six categories representing different molecular views of cellular characteristics. These include:

i) cell type proportions
ii) cell type specific gene expressions
iii) cell type specific pathway expressions
iv) cell type specific cell-cell interaction (CCI) scores
v) overall aggregated gene expressions
vi) spatial metrics

The different types of features constructed enable a more comprehensive multi-view understanding of each patient from a matrix of proteins x cells.

Given in the previous section, we clustered the cells into regions, we can use the region information as an additional layer of information on top of the cell types to examine region-specific cell-type specific features. 

```{r eval=FALSE}
region <- data_sce$region
region <- gsub("_" , "", region)

# concat the region information to the cell type 
data_sce$celltype <- paste0( data_sce$description , "-" , region)
```

```{r eval=params$evalc}
print("number of cells in each sample")
DT::datatable( data.frame(table( data_sce$metabricId )) , options = list(scrollX = TRUE))

print("number of cells in each celltype - Region specific cell type")
DT::datatable( data.frame(table( data_sce$celltype)) , options = list(scrollX = TRUE))

```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong> Discussion:</strong>

Q5: Are there any samples or cell types you would like to remove from the data?

</div>


## How to create molecular representations of patients {.tabset}

There are different ways you can use scFeatures to generate molecular representation for patients.   


### Selected features of interest

scFeatures can also generate selected feature types. For example, in the below code we run scFeatures to generate cell type proportion. 



```{r eval=params$evalc}

# scFeatures requires the following information 
# data,  sample, X, Y coordinates 

IMCmatrix <- assay(data_sce)
celltype <- data_sce$celltype
spatialCoords <- list(colData(data_sce)$Location_Center_X, colData(data_sce)$Location_Center_Y)

sample <- data_sce$metabricId 
cond  <- clinical[ match(sample, clinical$metabricId), ]$survivalgroup
sample <- paste0(sample, "_cond_", cond ) # append the condition to the patient so we can easily retrieve the patient condition 


scfeatures_result <- scFeatures( IMCmatrix, 
                                 sample = sample, celltype = celltype, spatialCoords = spatialCoords,
                                 feature_types = "proportion_raw", type = "spatial_p" )

```

```{r eval=params$evalc, fig.height=6, fig.width=20}

feature <- scfeatures_result$proportion_raw
feature <- feature[ grep("less than|more than", rownames(feature )),  ]

plot_barplot( feature ) + ggtitle("Proportion raw feature")

```


### Selected cell types of interest

Here we select the HR- CK7+ cell type.    

```{r eval=params$evalc}

index <-   grep("HR- CK7+-region" , celltype, fixed=T)
selected_celltype <- celltype[ index] 
selected_data  <-  IMCmatrix[, index]
selected_spatialCoords <- list(colData(data_sce)$Location_Center_X[index], 
                               colData(data_sce)$Location_Center_Y[index])

selected_sample <-  sample[index]

scfeatures_result <- scFeatures( selected_data, 
                                 sample = selected_sample, celltype = selected_celltype,
                                 spatialCoords = selected_spatialCoords,
                                 feature_types = "proportion_raw", type = "spatial_p" )


```

```{r eval=params$evalc, fig.height=6, fig.width=20}

feature <- scfeatures_result$proportion_raw
feature <- feature[ grep("less than|more than", rownames(feature )),  ]

plot_barplot( feature ) + ggtitle("Proportion raw feature")

```

### All cell types and features in one line of code 

The code below generates all feature types for all cell types, to save time we won't run it in today's workshop, **please just load the prepared RDS file in the following chunk.**

```

# here, we specify that this is a spatial proteomics data
# scFeatures support parallel computation to speed up the process 
scfeatures_result <- scFeatures(IMCmatrix, type = "spatial_p",
                                sample = sample, celltype = celltype, spatialCoords = spatialCoords,
                                ncores = 32)
```

```{r eval=params$evalc}
scfeatures_result <- readRDS("~/data/scfeatures_result.RDS")
```


## How to explore scFeatures output?

From the section above, we have generated a total of 13 feature types and stored them in a list. All generated feature types are stored in a matrix of samples x features. For example, the first list element contains the feature type `proportion_raw`, which contains the cell type proportion features for each patient sample. We could print out the first 5 columns and first 5 rows of the first element to see. 

```{r eval=params$evalc}
type(scfeatures_result)
```


```{r}
# we have generated a total of 13 feature types
names(scfeatures_result)
```


```{r}
lapply(scfeatures_result, dim)
# each row is a sample, each column is a feature 
```

```{r}
data.frame(scfeatures_result[[1]][1:5, 1:5])

```



The next question is, how can we visually explore all the features.     

### Visually exploring features 

Once the features are generated, you may wish to visually explore the features. 

Here we plot a volcano plot and a dotplot for the cell type specific expression feature.   



```{r eval=params$evalc, fig.height=5, fig.width=7}

gene_mean_celltype <- scfeatures_result$gene_mean_celltype
# select a certian cell type in a certain region 
gene_mean_celltype <- gene_mean_celltype [,  grep( "HR+ CK7--region5", colnames(gene_mean_celltype) , fixed= T) ] 
gene_mean_celltype <- t(gene_mean_celltype)
      
 
condition  <- unlist( lapply( strsplit( colnames(gene_mean_celltype) , "_cond_"), `[`, 2))
condition <- data.frame(sample = colnames(gene_mean_celltype), condition = condition )

# again , we are only interested in the short term survival and long term survival patients 
select_index <- which( condition$condition %in% c("less than 5 years",  "more than 10 years" ))

condition <- condition[ select_index, ]
gene_mean_celltype<- gene_mean_celltype [ ,  select_index]


# standard code to calculate log fold change each protein 
design <- model.matrix(~condition, data = condition)

fit <- lmFit(gene_mean_celltype, design)
fit <- eBayes(fit)
tT <- topTable(fit, n = Inf)
tT$gene <- rownames(tT)
p <- ggplot( tT , aes(logFC,-log10(P.Value) , text = gene ) )+
      geom_point(aes(colour=-log10(P.Value)), alpha=1/3, size=1) +
      scale_colour_gradient(low="blue",high="red")+
      xlab("log2 fold change") + ylab("-log10 p-value")  
 
p

```



```{r eval=params$evalc, fig.height=5, fig.width=7}
# order the proteins by log fold change 

tT <- tT[ order(tT$logFC, decreasing = T), ]
tT <- tT[1:20, ]
ggplot( tT , aes( y = reorder(gene, logFC) , x = logFC  ) )+
      geom_point(aes(colour=-log10(P.Value)), alpha=1/3, size=4) +
      scale_colour_gradient(low="blue",high="red")+
      xlab("logFC") + ylab("region specific cell type specfic features" ) 
 
 

```



<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong>Interactive Q&A:</strong>

Q6: Which figure do you prefer? The volcano plot or the dotplot? 

</div>


### Visualise distribution of features across patients {.tabset}

We can also visualise the distribution of the features across the patients. 
This helps to examine whether there exists any batch effect due to patient effect.   


#### Proportion raw


```{r eval=params$evalc, fig.height=6, fig.width=20}
feature <- scfeatures_result$proportion_raw
 feature <- feature[ grep("less than|more than", rownames(feature )),  ]
 plot_barplot(feature ) + ggtitle("Proportion raw feature")

```


#### Gene mean celltype


```{r eval=params$evalc}

feature <- scfeatures_result$gene_mean_celltype
feature <- feature[ grep("less than|more than", rownames(feature )),  ]
feature   <- feature[  , grep(  "HR+ CK7--region5" , colnames(feature) , fixed=T) ] # select the features from a particular cell type and a particular region 
plot_boxplot(feature) + ggtitle("Gene mean celltype feature")

```


#### Gene mean bulk

```{r eval=params$evalc}
 
feature <- scfeatures_result$gene_mean_bulk
feature <- feature[ grep("less than|more than", rownames(feature )),  ]
plot_boxplot(feature) + ggtitle("Gene mean bulk feature")

```

#### Nearest neighbour correlation 

```{r eval=params$evalc}
feature <- scfeatures_result$nn_correlation
feature <- feature[ grep("less than|more than", rownames(feature )),  ]
plot_boxplot(feature) + ggtitle("Nearest neighbour correlation feature")
```

 

### Automatic feature visualisation 
 
To accommodate for easier interpretation of the features, scFeatures contains a function `run_association_study_report` that enables the user to readily visualise and explore all generated features with one line of code.


```{r include=TRUE, eval=FALSE}
# specify a folder to store the html report. Here we store it in the current working directory. 
output_folder <-  getwd()

scfeatures_result_new <- scfeatures_result
for (i in 1:13){
  thisfeature <- scfeatures_result[[i]]
  thisfeature <- thisfeature[ grep("less than|more than", rownames(thisfeature )),  ]
  scfeatures_result_new[[i]] <- thisfeature
}

run_association_study_report(scfeatures_result_new, output_folder )
```






# Can we estimate recurrence risk? 

Recurrence risk estimation is a fundamental concern in medical research, particularly in the context of patient survival analysis. In this section, we will estimate recurrence risk using the molecular representation of patients to build a survival model. We will use classifyR to build the survival model. The patient outcome is time-to-event, so, by default, ClassifyR will use Cox proportional hazards ranking to choose a set of features and also Cox proportional hazards to predict risk scores. We will also demonstrate other available models in ClassifyR. 




## Building a survival model 

Recall in the previous section that we have stored the 13 matrices of different feature types in a list. Instead of manually retrieving each matrix from the list to build separate models, classifyR can directly take a list of matrices as an input and run a repeated cross-validation model on each matrix individually. Below, we run 5 repeats of 5-fold cross-validation.  A high score indicates prognosis of a worse outcome than a lower risk score. To save time, **just load the prepared RDS file.**

``` 
# We use the following variables:     
# timeRFS: "Time to Recurrence-Free Survival." It is the time period until recurrence occurs.    
# eventRFS: "Event in Recurrence-Free Survival."It indicates whether the event has occurred.    
# Breast.Tumour.Laterality: Laterality of tumors, eg, whether the tumor is located in left or right.     
# ER.Status: Whether the tumor is ER positive or ER negative.    
# Inferred.Menopausal.State: of the patient.    
# Grade: of the tumor.   
# Size: of the tumor.   

usefulFeatures <- c("Breast.Tumour.Laterality", "ER.Status", "Inferred.Menopausal.State", "Grade", "Size") 
nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result, function(metaFeature) 1:5))  # nFeatures provides a range of values of top-ranked features to try. It limits the model to be smaller. Use 3 for clinical features and 5 for scFeatures 
clinicalAndOmics <- append(list(clinical = clinical), scfeatures_result)

### generate classfyr result 

classifyr_result <- crossValidate(clinicalAndOmics, c("timeRFS", "eventRFS"),
                    extraParams = list(prepare = list(useFeatures = list(clinical = usefulFeatures))),
                    nFeatures = nFeatures, nFolds = 5, nRepeats = 5, nCores = 5)
```


```{r eval=params$evalc}
classifyr_result <- readRDS("~/data/classifyr_result_IMC.rds")
```



Cox proportional hazards is a classical statistical method, as opposed to machine learning methods like Random survival forest. These machine learning methods can build remarkably complex relationships between features, however their running time can be much longer than Cox proportional hazards. We use feature selection to limit the number of features considered to at most 100 per metafeature and to save time, **you can just load the prepared RDS file.** We will compare the predictive performance between these methods. 

```
nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result[2:length(scfeatures_result)], function(metaFeature) min(100, ncol(metaFeature))))
survForestCV <- crossValidate(clinicalAndOmics, outcome, nFeatures = nFeatures,
                classifier = "randomForest",
                nFolds = 5, nRepeats = 5, nCores = 5)
```

```{r eval=params$evalc}
survForestCV <- readRDS("~/data/survForestCV.RDS")
```


## Visualising the model performance of individual metafeatures 

To examine the distribution of prognostic performance, use `performancePlot`. If it is categorical data, the automatically chosen performance metric is balanced accuracy and if it is survival data, then it will automatically choose C-index. 

```{r eval=params$evalc}
tilt <- theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
performancePlot(append(classifyr_result, survForestCV),
                characteristicsList = list(x = "Assay Name", row = "Classifier Name"),
                orderingList = list("Assay Name" = c("clinical", names(scfeatures_result)))) + tilt
```

Note how the resultant plot is a `ggplot2` object and can be further modified. The same code could be used for a categorical classifier because the random forest implementation provided by the `ranger` package has the same interface for both.

Next, examine feature selection stability with `selectionPlot`.

```{r eval=params$evalc}
selectionPlot(append(classifyr_result, survForestCV),
                characteristicsList = list(x = "Assay Name", row = "Classifier Name"),
                orderingList = list("Assay Name" = c("clinical", names(scfeatures_result)))) + tilt 
 # If we have 5 repeats of 5 folds cross-validation we have 25 feature selections. The Y-axis is the percentage of the 25 cross-validations a feature is selected in. You'll want to see the boxes high to have feature selected stability.

distribution(classifyr_result[[2]], plot = FALSE) 
```

Using `samplesMetricMap` compare the per-sample C-index for Cox and Random Forest models for metafeature `gene_cor_celltype.`

```{r eval=params$evalc}
library(grid)
heatmap <- samplesMetricMap(list(classifyr_result[[7]], survForestCV[[7]]))
grid.draw(heatmap)
```

A few samples are predicted better by one model than another.

The per-sample C-index is a metric unique to ClassifyR. Models and feature selection approaches may be seen in the vignette or listed by `available()`.

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   

Q7: Is the highest predictive performance the only way to choose the best model or can other models be better for other reasons?
</div>


# Appendix 


## Explanation of spatial features 

- L function:

The L function is a spatial statistic used to assess the spatial distribution of cell types. It assesses the significance of cell-cell interactions, by calculating the density of a cell type with other cell types within a certain radius. High values indicate spatial association, low values indicate spatial avoidance.

```{r fig.height=4, fig.width=10, eval=params$evalc}
 
# select one patient 
one_sample  <- data_sce[ , data_sce$metabricId == "MB-0128"  ]
one_sample <- data.frame( colData(one_sample) )

one_sample$celltype <- one_sample$description

# select certain cell types to examine the interaction 
index <-  one_sample$celltype  %in% c("B cells", "Fibroblasts")
one_sample$celltype[!index] <- "others"
a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0128 - high L value with \n B cells interacting Fibroblasts")
 

one_sample$celltype <- one_sample$description
index <-  one_sample$celltype  %in% c("melano", "Tc.ae")
one_sample$celltype[!index] <- "others"
b <- ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0128 - low L value with \n B cells interacting HR_ CK7")
 
ggarrange(plotlist = list(a,b))
 
```




- Cell type interaction composition:

We calculate the nearest neighbours of each cell and then calculate the pairs of cell types based on the nearest neighbour. This allows us to summarise it into a cell type interaction composition.


```{r fig.height=6, fig.width=10, eval=params$evalc}
 
one_sample  <- data_sce[ , data_sce$metabricId == "MB-0263"  ]
one_sample <- data.frame( colData(one_sample) )

one_sample$celltype <- one_sample$description
 
a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient MB-0263")


feature  <- scfeatures_result$celltype_interaction
to_plot <- data.frame( t( feature[ "MB-0263_cond_more than 10 years" , ])  )
to_plot$feature <- rownames(to_plot) 
colnames(to_plot) <- c("value", "celltype interaction composition")
 
to_plot <- to_plot[ to_plot$value > 0.03 , ] 
b <- ggplot(to_plot, aes(x = reorder(`celltype interaction composition`, value) ,  y = value, fill=`celltype interaction composition`)) + geom_bar(stat="identity" ) + ylab("Major cell type interactions")  +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 

ggarrange(plotlist = list(a,b))
 
```



- Moran's I:   

Moran's I is a spatial autocorrelation statistic based on both location and values. It quantifies whether similar values tend to occur near each other or are dispersed.     


```{r fig.height=4, fig.width=10 , eval=params$evalc}

high  <- data_sce["Ki67", data_sce$metabricId == "MB-0132"  ]
high_meta <- data.frame( colData(high) ) 
high_meta$expression <- as.vector(logcounts( high)) 

low  <- data_sce["Ki67",  data_sce$metabricId == "MB-0249" ]
low_meta <- data.frame( colData(low) )
low_meta$expression <- as.vector(logcounts(low))


a <- ggplot(high_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient MB-0132 - high Moran's I in Ki67")

b <- ggplot(low_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient MB-0249 - low Moran's I in Ki67")

ggarrange(plotlist = list(a,b))
 

```



- Nearest Neighbor Correlation:    

This metric measures the correlation of proteins/genes between a cell and its nearest neighbour cell.   

```{r fig.height=5, fig.width=10, eval=params$evalc}


    
 plot_nncorrelation <- function(thissample , thisprotein){
   
       sample_name <- thissample
       thissample <- data_sce[, data_sce$metabricId ==     sample_name]
    
      
      exprsMat <- logcounts(thissample)
     
    # calculate NN correlation 
    cell_points_cts <- spatstat.geom::ppp(
            x = as.numeric(thissample$Location_Center_X ), y = as.numeric(thissample$Location_Center_Y),
            check = FALSE,
            xrange = c(
                min(as.numeric(thissample$Location_Center_X)),
                max(as.numeric(thissample$Location_Center_X))
            ),
            yrange = c(
                min(as.numeric(thissample$Location_Center_Y)),
                max(as.numeric(thissample$Location_Center_Y))
            ),
            marks = t(as.matrix(exprsMat))
        )
    
     value <-  spatstat.explore::nncorr(cell_points_cts)["correlation", ]
      value <-  value[  thisprotein]
     
    # Find the indices of the two nearest neighbors for each cell
    nn_indices <- nnwhich(cell_points_cts, k = 1)
    
    protein <-  thisprotein
    df <- data.frame(thiscell_exprs  = exprsMat[protein, ] , exprs =  exprsMat[protein,nn_indices ])
    
   p <-  ggplot(df, aes( x =thiscell_exprs ,  y = exprs , colour =  exprs  )) +
      geom_point(alpha = 0.3) + ggtitle(paste0( "Patient ", sample_name ,  " nn_corr = " ,  round(value, 2)  )) + scale_colour_viridis_c() + xlab("This cell expression") + ylab("Neighbouring cell expression")
   
   return (p ) 

}

    
p1 <- plot_nncorrelation("MB-0605",  "HER2")
p2 <- plot_nncorrelation("MB-0258",  "HER2")

ggarrange(plotlist = list(p1, p2))
 
```



## SessionInfo

```{r  eval=params$evalc}
sessionInfo()
```

## Acknowledgment 

The authors thank all their colleagues, particularly at The University of Sydney, Sydney Precision Data Science and Charles Perkins Centre for their support and intellectual engagement. Special thanks to Ellis Patrick, Shila Ghazanfar, Andy Tran for guiding and supporting the building of this workshop.