---
title: "Unlocking single cell spatial omics analyses with scdney"
author:
- name: Yue Cao^[yue.cao@sydney.edu.au], Andy Tran^[andy.t@sydney.edu.au], Dario Strbenac^[dario.strbenac@sydney.edu.au], Nicholas Robertson^[nicholas.robertson@sydney.edu.au], Jean Yang^[jean.yang@sydney.edu.au]
  affiliation:
  - 1. Sydney Precision Data Science Centre, University of Sydney, Australia;    
  - 2. School of Mathematics and Statistics, University of Sydney, Australia;     
  - 3. Charles Perkins Centre, University of Sydney, Australia;   
  - 4. Laboratory of Data Discovery for Health Limited (D24H), Science Park, Hong Kong SAR, China.  
date: 5 October, 2023

params:
  evalc: TRUE   ## EDIT to TRUE when generating output, otherwise 'FALSE'
  show: 'hide'  ## EDIT to 'as.is' when generating Suggestions, otherwise 'hide'
output:
  html_document:
    css: https://use.fontawesome.com/releases/v5.0.6/css/all.css
    code_folding: hide
    fig_height: 12
    fig_width: 12
    toc: yes
    number_sections: true
    toc_depth: 3
    toc_float: yes
    self_contained: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  message=FALSE, warning= FALSE )
```


```{r include=FALSE}
.libPaths("/dora/nobackup/yuec/R")
```


```{r eval=params$evalc}
library(SingleCellExperiment)
library(ggplot2)
library(scFeatures)
library(ClassifyR)
library(lisaClust)
library(ggthemes)
library(spicyR)
library(dplyr)
library(limma)
library(plotly)
library(scattermore)
library(tidyr)
library(survival)
library(survminer)
library(spatstat.geom)
library(scater)
library(scran)
library(SPOTlight)
library(reshape)
theme_set(theme_classic())
```



```{r eval=params$evalc}

## these are some codes for plotting 


plot_boxplot <- function( feature ){
  
  data <- t(feature)

  patient <- unlist( lapply( strsplit( colnames(data), "_cond_"), `[`, 1) ) 
  condition  <- unlist( lapply( strsplit( colnames(data), "_cond_"), `[`, 2))
  condition <- data.frame(condition = condition )
      
  design <- model.matrix(~condition, data = condition)
  fit <- lmFit(data, design)
  fit <- eBayes(fit)
  tT <- topTable(fit, n = Inf) 
  
  
  # selecting the top 10 DE features 
  top_gene <- rownames( tT)[1:10 ]
  rownames( condition) <- colnames(data)
   
  data_plot <-  data[top_gene, ]   
  
  data_plot <- melt(data_plot )
  
  colnames(data_plot) <- c("X1", "X2", "value")
   
  data_plot$condition <- unlist( lapply( strsplit(  as.character( data_plot$X2), "_cond_"), `[`, 2))
  
  
  p <- ggplot(data_plot, aes( x = X1, y = value , colour = condition)) + 
    geom_boxplot()  + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  
   
  return(p)
  
}
  


plot_barplot <- function(data , dodge=F  ){
  

  data$patient <- unlist( lapply( strsplit( rownames(data ), "_cond_"), `[`, 1))
  data$condition <- unlist( lapply( strsplit( rownames(data ), "_cond_"), `[`, 2))
  
  data <- as.data.frame( melt(data, id=c("patient", "condition")) )
 
 
  p <-   ggplot(data , aes( x = patient , y = value , fill = variable) ) +   
    geom_bar(stat="identity"   ) + facet_wrap(~condition, scale="free") + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  + 
    scale_fill_manual(values = color_codes)
 
  
 
 return (p)
  
 
 
}


```




# Overview

As single cell technology advances, the recent development of spatial omics allows us to examine the spatial organisation of cells within tissues in their native environment. This workshop will discuss the challenges and analytical focus associated with using multi-sample spatial datasets for disease prediction. We will also talk about general analytical strategies and the critical thinking questions that arise in the workflow.  

<br>
<div class="aimbox"> 
### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-pencil-alt fa-stack-1x fa-inverse"></i></span> Preparation and assumed knowledge {-}
- Knowledge of R syntax
- Familiarity with the [SingleCellExperiment class](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) 
- Basic knowledge in [single cell data analysis](https://bioconductor.org/books/release/OSCA/index.html). You can access our [previous workshops](https://github.com/SydneyBioX/scdney#scdney-workshops-series) for a quick review in single cell data analysis.
- Ability to install all required R packages, please check `sessionInfo` at the end of this document to ensure you are using the correct version. 
Familiarity with our previous workshop vignette on [Introduction to Single Cell RNA-seq Analysis](https://sydneybiox.github.io/BIS2019_SC/) 

### <span class="fa-stack fa"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-location-arrow fa-stack-1x fa-inverse"></i></span> Learning objectives {-}
- Describe and visualise spatial omics datasets     
- Calculate different measures that describe the spatial distribution of cell types
- Generate individual feature representations from a cell-level expression matrix 
- Perform multi-view disease outcome prediction with the package `ClassifyR`
- Develop understanding on 
  + how to assess the performance of classification models  
- Explore various strategies for disease outcome prediction using spatial omics data      
</div>

**Note:** This data analysis workshop offers participants the opportunity to engage in hands-on analysis using R. However, if you are not comfortable with coding in R, you can still acquire valuable interpretation skills by reviewing the output we provide in this file.
<br>

### Time outline

Structure of the 3-hour workshop:

| Activity                              | Time |
|---------------------------------------|------|
| Introduction                          | 15m  |
| Exploring spatial data                | 35m  |
| Feature engineering with scFeatures   | 50m  |
| Break                                 | 15m  |
| Survival analysis with ClassifyR      | 45m  |
| Identify cohort heterogeneity         | 20m  |
| Concluding remarks                    |      |



# Initial exploration and visualisation 



#### Data and background {-}  


In this demo, we look at a Visium dataset taken from Kuppe, C., Ramirez Flores, R. O., Li, Z., Hayat, S., Levinson, R. T., Liao, X., ... & Kramann, R. (2022). Spatial multi-omic map of human myocardial infarction. Nature, 608(7924), 766-777.    

Visium captures spatial information, creating images that display the distribution of different cell types and their associated gene expression patterns in the tissue.      

In this dataset, the authors quantified the expression of >10000 genes in control and in patients with myocardial infarction. In this demo, we examine patients defined to be myogenic group and ischaemic group. Myogenic group is defined by sample taken from control and unaffected remote zone, ischaemic group is defined by sample taken from ischaemic zone. 


## Exploration 1: How complex is my data ? 

Examine the data objects:   
- The dataset contains 11,681 genes and 19,000 cells (after subsampling).   
- The outcome is 11 myogenic samples (4 from control, 7 from remote zone) and 8 ischaemic samples.    


```{r eval=params$evalc}

data_sce <- readRDS("~/data/small_data.rds")
 
data_sce
## Expression matrix is stored in genes by cells matrix
logcounts(data_sce)[1:7, 1:7]

## The object stores meta data (such as patient outcome information) about each cell
## the metadata is stored in colData() for a spatialexperiment object.
# we need to convert to a data.frame to be input into datatable function
DT::datatable( data.frame(colData(data_sce))[1:5, ], options = list(scrollX = TRUE))

```


 
 
## Exploration 2: How to visualise my data ?

Typically in a spatial data, we perform dimension reduction to reduce and project the high dimensional cell by gene matrix on to 2D space. This allows us to visualise various things of interest, such as distribution of cell types and disease outcomes.  

Visium is a spot-based technology, meaning that each spot capture 1-10 cells. Therefore each spot may represent a mixture of cells from different cell types. In this dataset, the author used cell2location which is a spatial deconvolution tool to predict the cell type probability or composition of each of the spot. There are also many other deconvolution tools available, eg, CARD published in Ma, Y., & Zhou, X. (2022). Spatially informed cell-type deconvolution for spatial transcriptomics. Nature biotechnology, 40(9), 1349-1359.     

For demonstration purpose, in the plot below we visualise each spot using the cell type with maximum probability.   
 
```{r eval=params$evalc}

data_sce <- runUMAP(data_sce, exprs_values = "logcounts", scale=TRUE, min_dist = 0.3)

```



```{r eval=params$evalc, fig.height=8, fig.width=12}
## To highlight can highlight by [EXPLAIN]

a <- plotUMAP(data_sce, colour_by = "celltype")
b <- plotUMAP(data_sce, colour_by = "condition")
c <- plotUMAP(data_sce, colour_by = "sample")

## this allows us to combine multiple plot in a grid format 
ggarrange(plotlist = list(a,b,c))


```





 

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>     

- Q1: Is there patient batch effect?    
- Q2: Are the myogenic group and ischaemic group easy or difficult to distinguish?     
- Any interesting patterns from the plot?       
   

</div>



## Exploration 3: Is there a spatial structure in my data?


The advantage with spatial omics is that we can examine the organisation of the cell types as it occurs on the tissue slide. Here we visualise one of the slides from a selected patient. As an optional exercise, you can: 

- permute the cell type label.   
- permute the spatial coordinate.           

to give a sense of what is random ordering.       
 

```{r eval=params$evalc, fig.height=4, fig.width=6}
# SET UP code for visualising 

# this section of the code is to set consistent colour for each cell type throughout this rmarkdown
# we use the colour palette Tableau
# because it only has 10 colours and we have 11 cell types, we colour the last cell type grey. 
celltype <- c("Adipocyte" , "Cardiomyocyte" , 
              "Endothelial" ,  "Fibroblast" , "Lymphoid" ,    
              "Mast" ,   "Myeloid" , 
              "Neuronal" , "Pericyte" , "Cycling.cells", "vSMCs" )

tableau_palette <- scale_colour_tableau() 
color_codes <-  c( tableau_palette$palette(10) , "lightgrey")
names(color_codes) <- celltype


```
 
Here we choose a particular patient "IZ_P9_cond_Ischaemic" (a patient in the ischaemic group) and visualise its spatial pattern. 
 
```{r eval=params$evalc}

# select one sample to visualise  
one_sample_data <- data_sce[, data_sce$sample  ==  "IZ_P9_cond_Ischaemic"]
one_sample  <- data.frame( colData(one_sample_data) )
a <- ggplot(one_sample, aes(x = spatial_x , y = spatial_y, colour = celltype)) + geom_point(alpha=0.7) +  scale_colour_manual(values = color_codes) + ggtitle("Original slide")

 
```



```{r  eval=params$evalc, fig.height=4, fig.width=6}

## Optional: Permute the cell type labels

one_sample$celltype_permute <- sample(one_sample$celltype)
b <- ggplot(one_sample, aes(x = spatial_x , y =  spatial_y, colour =celltype_permute)) + geom_point(alpha=0.7) +  scale_colour_manual(values = color_codes)  + ggtitle("Permute the cell type label")

```


 

```{r eval=params$evalc, fig.height=4, fig.width=12}

## Optional: Permute the spatial coordinate

one_sample$spatial_x_permute <- sample(one_sample$spatial_x)
one_sample$spatial_y_permute <- sample(one_sample$spatial_y)

c <- ggplot(one_sample, aes(x = spatial_x_permute , y = spatial_y_permute, colour = celltype)) + geom_point(alpha=0.7) +  scale_colour_manual(values = color_codes) + ggtitle("Permute the X, Y coordinate")


ggarrange(plotlist = list(a,b,c), ncol =3 )
```

Comparing the above plot shows spatial randomness. 



## Exploration 4: Visium specific visualisation 

Instead of plotting the cell type with maximum probability, we can also visualise the cell type composition of each spot using pie chart. 

```{r eval=params$evalc}

x <- data.frame( imagecol = one_sample$spatial_y, 
                 imagerow = one_sample$spatial_x)
 
rownames(x) <- paste0("Spot", 1:nrow(x))

y <- data.frame( colData(one_sample_data)[ ,celltype  ] )
 
rownames(y) <- paste0("Spot", 1:nrow(y))


## we use a function to plot the piechart
plotSpatialScatterpie(x = x, y = y , pie_scale = 0.7) + theme_classic() +  scale_fill_manual(values = color_codes) + ylab("spatial_y") + xlab("spatial_y")
  
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   

Q3: Is there a structure in the data or is the cell type randomly distribution? 

</div>


#  Describing tissue microenvrionments and cellular neighbourhoods  

## Do cell type co-localise in specfic regions?

We begin by examine how can we identify and visualise regions of tissue where spatial associations between cell-types is similar? There are many packages that perform this task andhere we use the lisaClust function [https://www.bioconductor.org/packages/devel/bioc/html/lisaClust.html] that is based on “local L-function” to spatially clusters cells into different regions with similar cell type composition.

```{r eval=params$evalc}
set.seed(51773)
 

BPPARAM <- simpleSeg:::generateBPParam(2)

# Cluster cells into spatial regions with similar composition.
data_sce  <- lisaClust(
  data_sce ,
  k = 5,
  Rs = c(20, 50, 100),
  sigma = 50,
  spatialCoords = c("spatial_x", "spatial_y"),
  cellType = "celltype",
  imageID = "sample" ,
  regionName = "region",
  BPPARAM = BPPARAM
)
 

```


 

##  Which regions appear to be different between the ischaemic and myogenic patients? 

### Visualise regions on individual level 

Using the slide we previously shown, visualise the region output. 

```{r eval=params$evalc, fig.height=3, fig.width=10}

metadata <- colData(data_sce)
metadata <- metadata[ metadata$sample == "IZ_P9_cond_Ischaemic",  ]
metadata <- data.frame(metadata)
metadata$celltype  <- as.character(metadata$celltype )

plotlist <- list()
plotlist_celltype <- list()
thisregion  <-  unique(metadata$region)[1]


tableau_palette <- scale_colour_tableau() 
color_codes <- tableau_palette$palette( 10 )
color_codes <- c(color_codes, "darkgrey" , "grey90") 

names(color_codes) <- c( celltype ,  "other regions")


# put this in a function 
# show the hatching plot as well 
for ( thisregion in sort(unique(metadata$region))){
        
        selected_region_index <-  metadata$region == thisregion
        
        metadata$selected_region <-  "other regions"
        metadata$selected_region[selected_region_index] <- "selected region"
        
        metadata$selected_celltype <- metadata$celltype
        metadata$selected_celltype[!selected_region_index ] <-   "other regions"
        
        # metadata$celltype <- factor(metadata$celltype, levels = c(unique(metadata$celltype), "other regions"))

       p <- ggplot(metadata, aes(x = spatial_x , y = spatial_y, colour = selected_region  )) + 
         geom_point( alpha = 0.8 ) + ggtitle(thisregion) + scale_colour_manual(values = c("grey" , "red"))
         
       
    
       p2 <-  ggplot(metadata, aes(x = spatial_x , y = spatial_y, colour =  selected_celltype )) +
         geom_point(alpha = 0.8 ) + ggtitle(thisregion) + scale_colour_manual(values =  color_codes)
       
      plotlist [[thisregion ]] <- p
       
      plotlist_celltype [[thisregion ]] <- p2
}

ggarrange(plotlist = plotlist , ncol = 5, nrow = 1 , common.legend = T )
ggarrange(plotlist = plotlist_celltype , ncol = 5, nrow = 1 , common.legend = T )




```


  
###  Visualise regions across patients

We can better interpret the region output by summarising the proportion of each cell type in a region across the patients. 

Looking at the composition of cell types in each region, comparing between ischaemic and myogenic. 


```{r  eval=params$evalc, fig.height=4, fig.width=10}

df <- data.frame(colData( data_sce))
 

# comment every line of the code 

df_plot <- NULL
for ( thispatient in unique(df$sample)){
  this_df <- df[df$sample == thispatient, ]
  temp_df <-   table( this_df$region, this_df$celltype )
  temp_df <-  temp_df / rowSums(temp_df)
   temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$reponse <- unique( this_df$condition)
  df_plot <- rbind(df_plot, temp_df)
}

df_plot <- df_plot %>% dplyr::group_by( Var1 , Var2, reponse) %>% 
  summarise(mean_proportion = mean(Freq))
  
 
ggplot(df_plot, aes(y = Var2, x = Var1 ,colour =mean_proportion  , size = mean_proportion ))+  geom_point() + 
  facet_grid(~reponse, scales = "free", space = "free" ) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  xlab("Region" ) + ylab("Celltype") + scale_colour_viridis_c()
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>   
 
Q4: Which regions would you focus on next ? 

</div>




```{r  eval=params$evalc, fig.height=4, fig.width=10}

df <- data.frame(colData( data_sce))

df <- df %>% dplyr::group_by(sample , condition , region) %>%
  count(celltype) %>%
  mutate(proportion = n / sum(n))


ggplot(df, aes(y = proportion, x = sample , fill = celltype))+ geom_col()+facet_grid(~region+condition, scales = "free", space = "free" ) + scale_fill_manual(values = c(color_codes))  +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())


```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<i class="far fa-chart-bar fa-stack-1x fa-inverse"></i>
</span> <strong>Interactive Q&A:</strong>

Q5: Does your conclusion change after looking at a different plot     


</div>




## Further exploration by visualise selected regions  

 
Let's focus on region 2 and visualise the boxplot of cell type distribution. 



```{r eval=params$evalc, fig.height=4, fig.width= 12 }

df <- data.frame(colData( data_sce))



df_plot <- NULL
for ( thispatient in unique(df$sample )){
  this_df <- df[df$sample == thispatient, ]
  temp_df <-   table( this_df$region, this_df$celltype)
  temp_df <-  temp_df / rowSums(temp_df)
  temp_df <- data.frame(  temp_df)
  temp_df$patient <-  thispatient
  temp_df$reponse <- unique( this_df$condition )
  df_plot <- rbind(df_plot, temp_df)
}

df_plot_region_1 <- df_plot[df_plot$Var1 == "region_2", ]
 
a <- ggplot(df_plot_region_1, aes(x =  Var2,  y = Freq, colour = reponse)) +
  geom_boxplot()+ 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  ylab("Proportion") + xlab("Cell type")+ ggtitle("Region 2") + ylim(0,1)

a
 




```

 
<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong>Discussion:</strong>

Comparing the cell type composition in the region, what can you tell about the regions? 

</div>

 

 



#  How do we generate molecular representation for each individual ?   

In this demo, we use scFeatures to generate molecular representation for each patient. The molecular representation is interpretable and hence facilitates downstream analysis of the patient. Overall, scFeatures generates features across six categories representing different molecular views of cellular characteristics. These include:
- i) cell type proportions
- ii) cell type specific gene expressions
- iii) cell type specific pathway expressions
- iv) cell type specific cell-cell interaction (CCI) scores
- v) overall aggregated gene expressions
- vi) spatial metrics
The different types of features constructed enable a more comprehensive multi-view understanding of each patient from a matrix of proteins x cells.




```{r eval=params$evalc}

 
print("number of cells in each sample")
table(data_sce$sample)
# metadata <- data.frame( table(data_sce$sample) )
# colnames(metadata)[1] <- "Patient"
# DT::datatable(metadata , options = list(pageLength = 5), width = "400px")

print("number of cells in each celltype")
table(data_sce$celltype)

# metadata <- data.frame( table(data_sce$celltype) )
# colnames(metadata)[1] <- "Region specific cell type"
# DT::datatable(metadata , options = list(pageLength = 5), width = "400px")
#   
```


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong>Discussion:</strong>

Is there any sample or cell types you would like to remove from the data?

</div>




## How to create one molecular representations for an individual? {.tabset}
 

There are different ways you can use scFeatures to generate molecular representation for patients.   


### Selected features of interest

scFeatures can also generate selected feature types. For example, in the below code we run scFeatures to generate cell type proportion. 


```{r}
#scFeatures requires the following columns 
#  data, sample, x_cord and y_cord
data <- logcounts( data_sce )
sample <- data_sce$sample
spatialCoords <- list(data_sce$spatial_x, data_sce$spatial_y)


# for spatial transcriptomics, we also need to specify the cell type prediction of each spot 
prediction.scores <- colData(data_sce)[, celltype]
prediction.scores <- as.matrix( t(prediction.scores)  )


scfeatures_result <- scFeatures(data = data ,  sample = sample, 
                spatialCoords = spatialCoords , spotProbability = prediction.scores, 
                feature_types = "proportion_raw",
                type ="spatial_t" )
```

 
```{r eval=params$evalc }
feature <- scfeatures_result$proportion_raw
plot_barplot( feature ) + ggtitle("Proportion raw feature")

```

 
### All cell types and features in one line of code 

 
The code below generates all feature types for all cell types, to save time we won't run it in today's workshop, **please just load the prepared RDS file in the following chunk.**

```
scfeatures_result <- scFeatures(data = data ,  sample = sample, 
                spatialCoords = spatialCoords , spotProbability = prediction.scores, 
                type ="spatial_t", ncores = 10)
```


```{r eval=params$evalc}
scfeatures_result <- readRDS("~/data/scfeatures_result_matrix.rds")
```
 

## How to explore scFeatures output?

From the section above, we have generated a total of 13 feature types and stored them in a list. All generated feature types are stored in a matrix of samples by features.
For example, the first list element contains the feature type “proportion_raw”, which contains the cell type proportion features for each patient sample. We could print out the first 5 columns and first 5 rows of the first element to see.


```{r eval=params$evalc}
scfeatures_result <- readRDS("~/data/scfeatures_result_matrix.rds")
 
# we have generated a total of 13 feature types
names(scfeatures_result )


# each row is a sample, each column is a feature 

meta_table <- data.frame(round ( scfeatures_result [[1]][1:5, 1:5] , 2))
DT::datatable(meta_table , options = list(scrollX = TRUE))
 


```


### Visually exploring features 


Once the features are generated, you may wish to visually explore the features. 

Here we plot a volcano plot and a dotplot for the cell type specific expression feature.   


```{r eval=params$evalc, fig.height=5, fig.width=7}
gene_mean_bulk <- scfeatures_result$gene_mean_bulk
# this transposes the data
# in bioinformatics conversion, features are stored in rows 
# in statistics convention, features are stored in columns
gene_mean_bulk <- t(gene_mean_bulk)
      
 
condition  <- unlist( lapply( strsplit( colnames(gene_mean_bulk), "_cond_"), `[`, 2))
condition <- data.frame(condition = condition )
design <- model.matrix(~condition, data = condition)
fit <- lmFit(gene_mean_bulk, design)
fit <- eBayes(fit)
tT <- topTable(fit, n = Inf)
tT$gene <- rownames(tT)
p <- ggplot( tT , aes(logFC,-log10(P.Value) , text = gene ) )+
      geom_point(aes(colour=-log10(P.Value)), alpha=1/3, size=1) +
      scale_colour_gradient(low="blue",high="red")+
      xlab("log2 fold change") + ylab("-log10 p-value")  
 
p

```



```{r eval=params$evalc, fig.height=5, fig.width=7}
tT <- tT[ order(tT$logFC, decreasing = T), ]
tT <- tT[1:20, ]
ggplot( tT , aes( y = reorder(gene, logFC) , x = logFC  ) )+
      geom_point(aes(colour=-log10(P.Value)), alpha=1/3, size=4) +
      scale_colour_gradient(low="blue",high="red")+
      xlab("logFC") + ylab("region specific cel type specfic features" ) 
 
 

```

<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong>Interactive Q&A:</strong>

Q6: Which figure do you prefer? The volcano plot or the dotplot? 

</div>


### Visualise distribution of features across patients {.tabset}

We can also visualise the distribution of the features across the patients. 
This helps to examine whether there exists any batch effect due to patient effect.   


#### Proportion raw

```{r eval=params$evalc}

feature <- scfeatures_result$proportion_raw
 
plot_barplot(feature ) + ggtitle("Proportion raw feature")

  
```


#### Gene mean celltype

```{r eval=params$evalc}

feature <- scfeatures_result$gene_mean_celltype
feature   <- feature[  , grep("Cardio", colnames(feature)) ]
plot_boxplot(feature) + ggtitle("Gene mean celltype feature")


```

#### Pathway mean 

```{r}

feature <- scfeatures_result$pathway_mean
plot_boxplot(feature) + ggtitle("Pathway mean feature")


 
```

#### Gene mean bulk 

```{r}
feature <- scfeatures_result$gene_mean_bulk
plot_boxplot(feature) + ggtitle("Gene mean bulk feature")


```

#### Nearest neighbour correlation

```{r}
feature <- scfeatures_result$nn_correlation
plot_boxplot(feature) + ggtitle("Nearest neighbour correlation feature")

```

 
### Automatic feature visualisation 

To accommodate for easier interpretation of the features, scFeatures contains a function run_association_study_report that enables the user to readily visualise and explore all generated features with one line of code.


```{r include=TRUE, eval=FALSE}
# specify a folder to store the html report. Here we store it in the current working directory. 
output_folder <-  getwd()
run_association_study_report(scfeatures_result, output_folder )
```



## Are the generated features sensible ? 


<div class="aimbox"> 
<span class="fa-stack fa-lg">
<i class="fa fa-circle fa-stack-2x"></i>
<span class="far fa-comment fa-stack-1x fa-inverse"></span>
</span> <strong>Interactive Q&A:</strong>

Using the HTML, we can look at some of the critical thinking questions that a researcher would ask about the generated features. These questions are exploratory and there is no right or wrong answer.   

Q7: Do the generated features look reasonable?         
Which cell type(s) would you like to focus on at your next stage of analysis?       
Which feature type(s) would you like to focus on at your next stage of analysis?       
Q8: Are the conditions in your data relatively easy or difficult to distinguish?       

</div>



# Can we classify or discrimiante between the ischaemic and myogenic samples ? 

In this section we build a classification model to predict whether the samples belong to the ischaemic or myogenic group.   


## Building classification model

Recall in the previous section that we have stored the 13 feature types matrix in a list. Instead of manually retrieving each matrix from the list to build separate models, classifyR can directly take a list of matrices as an input and run repeated cross-validation model on each matrix individually.

Below, we run 5 repeats of 3 folds cross-validation. 

```{r eval=FALSE, include=TRUE}

outcome = scfeatures_result[[1]] %>% rownames %>% strsplit("_cond_") %>% sapply(function(x) x[2])
table(outcome)

### generate classfyr result 
classifyr_result <- crossValidate(scfeatures_result,
                                 outcome, 
                                 classifier = "kNN",
                                 nFolds = 3, 
                                 nRepeats = 5, 
                                 nCores = 5  )


```


## Visualising the classification performance

To examine the classification model performance, we first need to specify a metric to calculate. Here, we calculate the balanced accuracy.

```{r eval=params$evalc}
classifyr_result <-  readRDS("~/data/classifyr_result.rds")

classifyr_result <- lapply(classifyr_result, 
                           function(x) calcCVperformance(x, performanceType = "Balanced Accuracy"))
```

Format the output and visualise the accuracy using boxplots.


```{r eval=params$evalc}

level_order <- names(scfeatures_result)

p  <- performancePlot(classifyr_result) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  scale_x_discrete(limits = level_order)  

p

```



# Appendix

## Explanation of spatial features 

- L function:

The L function is a spatial statistic used to assess the spatial distribution of cell types. It assess the significance of cell-cell interactions, by calculating the density of a cell type with other cell types within a certain radius. High values indicate spatial association, low values indicate spatial avoidance.  



```{r eval=params$evalc, fig.height=4, fig.width=10}

tableau_palette <- scale_colour_tableau() 
color_codes <- tableau_palette$palette( 10 )
color_codes <- c(color_codes, "darkgrey" , "grey90") 

names(color_codes) <- c( celltype ,  "other regions")
 


one_sample_data  <- data_sce[ , data_sce$sample == "IZ_P10_cond_Ischaemic"  ]

one_sample <- data.frame( colData(one_sample_data) )
index <-  one_sample$celltype  %in% c("Cardiomyocyte", "Myeloid")
one_sample$celltype <- as.character(one_sample$celltype)
one_sample$celltype[!index] <- "others"
a <- ggplot( one_sample, aes(x = spatial_x , y = spatial_y, colour = celltype )) + geom_point()  + scale_colour_manual(values = c("steelblue", "coral", "grey"))  + ggtitle( "Patient P10 - high L value with \n cardiomyocyte interacting myeloid")
 
one_sample <- data.frame( colData(one_sample_data) )
index <-  one_sample$celltype  %in% c("Cardiomyocyte", "Cycling.cells")
one_sample$celltype <- as.character(one_sample$celltype)
one_sample$celltype[!index] <- "others"
b <- ggplot( one_sample, aes(x = spatial_x , y = spatial_y, colour = celltype )) + geom_point() + scale_colour_manual(values = c("steelblue", "coral", "grey"))  + ggtitle( "Patient 10 - low L value with  \n cardiomyocyte interacting cycling cells")
 
ggarrange(plotlist = list( a , b))

 

```




- Cell type interaction composition:

We calculate the nearest neighbours of each cell and then calculate the pairs of cell type based on the nearest neighbour. This allow us to summarised it into a cell type interaction composition.


```{r eval=params$evalc, fig.height=6, fig.width=10}

tableau_palette <- scale_colour_tableau() 
color_codes <- tableau_palette$palette( 10 )
color_codes <- c(color_codes, "darkgrey" , "grey90") 

names(color_codes) <- c( unique(data_sce$celltype)  )
 

tableau_palette <- scale_colour_tableau() 
color_codes <-  c( tableau_palette$palette(10) , "lightgrey")
names(color_codes) <- celltype



one_sample  <- data_sce[ , data_sce$sample == "IZ_P10_cond_Ischaemic"  ]
one_sample <- data.frame( colData(one_sample) )
 
a <- ggplot( one_sample, aes(x = spatial_x , y = spatial_y, colour = celltype )) + geom_point( alpha = 0.8)  + scale_colour_manual(values = color_codes)  + ggtitle( "Patient P10")


feature  <- scfeatures_result$celltype_interaction
to_plot <- data.frame( t( feature["IZ_P10_cond_Ischaemic" , ])  )
to_plot$feature <- rownames(to_plot) 
colnames(to_plot)[2] <- "celltype interaction composition"
 to_plot <- to_plot[ order(to_plot$IZ_P10_cond_Ischaemic , decreasing = T), ]
 to_plot <-  to_plot[1:5 , ]
 # to_plot <- to_plot[ to_plot$IZ_P10_cond_Ischaemic  > 0.03 , ] 
b <- ggplot(to_plot, aes( x =  reorder(`celltype interaction composition`, IZ_P10_cond_Ischaemic) ,  y = IZ_P10_cond_Ischaemic  ,fill = `celltype interaction composition`)) + geom_bar(stat="identity", fill = "steelblue" ) + ylab("Cell type interactions value")  + xlab("Major cell type interactions") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 

ggarrange(plotlist = list( a , b))

```



- Moran's I:   

Moran's I is a spatial autocorrelation statistic based on both location and values. It quantifies whether similar values tend to occur near each other or dispersed.     


```{r eval=params$evalc, fig.height=4, fig.width=10}




high  <- data_sce["PDGFD", data_sce$sample == "IZ_P16_cond_Ischaemic"  ]
high_meta <- data.frame( colData(high) ) 
high_meta$expression <- as.vector(logcounts( high)) 

low  <- data_sce["KIF22"  , data_sce$sample == "IZ_P16_cond_Ischaemic" ]
low_meta <- data.frame( colData(low) )
low_meta$expression <- as.vector(logcounts(low))


a <- ggplot(low_meta, aes(x = spatial_x , y = spatial_y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient P16 - low Moran's I in KIF22")

b <- ggplot(high_meta, aes(x = spatial_x , y = spatial_y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle("Patient P16 - high Moran's I in PDGFD")

ggarrange(plotlist = list( a , b))


```



- Nearest Neighbor Correlation:    

This metric measures the correlation of proteins/genes between a cell and its nearest neighbor cell.   

Here we pick the gene "COL1A1" as an example to illustrate the concept.  

```{r eval=params$evalc, fig.height=5, fig.width=10}


plot_nncorrelation <- function(thissample , thisprotein){
   
       sample_name <- thissample
       thissample <- data_sce[, data_sce$sample ==     sample_name]
    
      
      exprsMat <- logcounts(thissample)
     
    
    cell_points_cts <- spatstat.geom::ppp(
            x = as.numeric(thissample$spatial_x), y = as.numeric(thissample$spatial_y),
            check = FALSE,
            xrange = c(
                min(as.numeric(thissample$spatial_x)),
                max(as.numeric(thissample$spatial_x))
            ),
            yrange = c(
                min(as.numeric(thissample$spatial_y)),
                max(as.numeric(thissample$spatial_y))
            ),
            marks = t(as.matrix(exprsMat))
        )
    
     value <-  spatstat.explore::nncorr(cell_points_cts)["correlation", ]
      value <-  value[  thisprotein]
     
    # Find the indices of the two nearest neighbors for each cell
    nn_indices <- nnwhich(cell_points_cts, k = 1)
    
    protein <-  thisprotein
    df <- data.frame(thiscell_exprs  = exprsMat[protein, ] , exprs =  exprsMat[protein,nn_indices ])
    
   p <-  ggplot(df, aes( x =thiscell_exprs ,  y = exprs , colour =  exprs  )) +
      geom_point(alpha = 0.3) + ggtitle(paste0( "Patient ", sample_name ,  " nn_corr = " ,  round(value, 2)  )) + scale_colour_viridis_c() + xlab("This cell expression") + ylab("Neighbouring cell expression")
   
   return (p ) 

}

    
p1 <- plot_nncorrelation( "IZ_P9_cond_Ischaemic" ,  "COL1A1" )
p2 <- plot_nncorrelation( "control_P1_cond_Myogenic"  ,  "COL1A1" )
ggarrange(plotlist = list( p1 , p2))
  
 
```

 



## Session info

```{r eval=params$evalc}
sessionInfo()
```



## Acknowledgment 

The authors thank all their colleagues, particularly at The University of Sydney, Sydney Precision Data Science and Charles Perkins Centre for their support and intellectual engagement. Special thanks to Ellis Patrick, Shila Ghazanfar, Andy Tran for guiding and supporting the building of this workshop.



